{
  "project_info": {
    "name": "CellSorter",
    "version": "2.0.0", 
    "last_updated": "2025-01-02",
    "requirements_compliance": "97%",
    "production_ready": true,
    "three_mode_architecture": true
  },
  "tasks": [
    {
      "id": "TASK-001",
      "title": "Implement Image Loading Module",
      "description": "Create the image handler module to load and display TIFF, JPG, JPEG, and PNG files",
      "type": "feature",
      "priority": "high",
      "status": "completed",
      "effort": "medium",
      "completion_date": "2025-06-25",
      "dependencies": [],
      "functional_requirement": "FR1.1",
      "acceptance_criteria": [
        "✅ Support TIFF, JPG, JPEG, PNG formats up to 2GB",
        "✅ Handle multi-channel TIFF files",
        "✅ Display images with pan and zoom (10%-1000%)",
        "✅ Maintain quality during zoom (1x-100x magnification)",
        "✅ Load time < 5 seconds for 500MB files",
        "✅ Show loading progress for large files"
      ],
      "implementation_file": "src/models/image_handler.py",
      "technical_notes": "Complete implementation using OpenCV and QGraphicsView with efficient memory management"
    },
    {
      "id": "TASK-002",
      "title": "Create CSV Parser Module",
      "description": "Implement CellProfiler CSV parsing with validation",
      "type": "feature",
      "priority": "high",
      "status": "completed",
      "effort": "medium",
      "completion_date": "2025-06-25",
      "dependencies": [],
      "functional_requirement": "FR1.2",
      "acceptance_criteria": [
        "✅ Parse CellProfiler CSV format",
        "✅ Validate required bounding box columns",
        "✅ Support up to 100,000 cell records",
        "✅ Parse time < 3 seconds for 50,000 records",
        "✅ Display validation errors with column references",
        "✅ Handle missing/invalid data gracefully"
      ],
      "implementation_file": "src/models/csv_parser.py",
      "technical_notes": "Complete implementation using pandas with robust error handling"
    },
    {
      "id": "TASK-003",
      "title": "Build Scatter Plot Widget",
      "description": "Create interactive scatter plot visualization using matplotlib",
      "type": "feature",
      "priority": "high",
      "status": "completed",
      "effort": "large",
      "completion_date": "2025-06-25",
      "dependencies": ["TASK-002"],
      "functional_requirement": "FR2.1, FR2.2",
      "acceptance_criteria": [
        "✅ Embed matplotlib in Qt widget",
        "✅ User selects any two numeric columns for axes",
        "✅ Plot renders in < 2 seconds for 50,000 points",
        "✅ Support pan, zoom, reset interactions",
        "✅ Implement rectangle selection with shift+drag",
        "✅ Real-time highlighting and selection count",
        "✅ Export plot as PNG/SVG"
      ],
      "implementation_file": "src/components/widgets/scatter_plot.py",
      "technical_notes": "Complete implementation with matplotlib Qt backend and custom selection handler"
    },
    {
      "id": "TASK-004",
      "title": "Develop Selection Manager",
      "description": "Create system for managing cell selections with colors and labels",
      "type": "feature",
      "priority": "high",
      "status": "completed",
      "effort": "medium",
      "completion_date": "2025-06-25",
      "dependencies": ["TASK-003"],
      "functional_requirement": "FR2.3",
      "acceptance_criteria": [
        "✅ Track multiple independent selections",
        "✅ Assign from 16 predefined colors",
        "✅ Support custom labels for selections",
        "✅ Display table: checkbox, label, color, well, count",
        "✅ Edit selection properties after creation",
        "✅ Delete individual selections",
        "✅ Color consistency between plot and image"
      ],
      "implementation_file": "src/models/selection_manager.py",
      "technical_notes": "Complete model class implementation with Qt signals for state management"
    },
    {
      "id": "TASK-005",
      "title": "Coordinate Calibration System Implementation",
      "description": "Implement coordinate transformation functionality through 2-point calibration system using 3-mode architecture",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "effort": "large",
      "dependencies": ["TASK-001"],
      "functional_requirement": "FR4.1, FR4.2",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "Simulate calibration logic in headless environment",
          "requirements": [
            "Verify coordinate transformation matrix calculation algorithm",
            "Simulate minimum distance validation between 2 points",
            "Verify affine transformation accuracy to 0.1 micrometer",
            "Test inverse transformation verification logic",
            "Simulate UI interaction in headless environment"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-calibration-logic",
            "pytest tests/dev_mode/test_coordinate_calibration.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "Verify consistency between GUI and headless logic",
          "requirements": [
            "Set calibration points with actual mouse clicks",
            "Compare GUI coordinate input with headless calculation results",
            "Verify synchronization of visual indicators with calculation results",
            "Confirm real-time coordinate display accuracy"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-calibration-ui",
            "pytest tests/dual_mode/test_calibration_consistency.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "Verify user experience and performance in production environment",
          "requirements": [
            "Mouse click accuracy on actual hardware",
            "Calibration dialog usability",
            "Performance optimization with large images",
            "Error handling and recovery options"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-calibration",
            "pytest tests/gui_mode/test_calibration_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "User clicks 2 reference points on image",
        "Manual input of stage coordinates",
        "Calculate affine transformation matrix",
        "Visual indicators for calibration points",
        "Minimum distance validation between points",
        "Transformation with 0.1 micrometer accuracy",
        "Real-time coordinate display",
        "Inverse transformation for verification"
      ],
      "implementation_file": "src/models/coordinate_transformer.py, src/components/dialogs/calibration_dialog.py",
      "technical_notes": "Calibration system with 3-mode architecture - NumPy affine calculations and comprehensive UI"
    },
    {
      "id": "TASK-006",
      "title": "Protocol Exporter Implementation",
      "description": "Implement .cxprotocol file generation for CosmoSort hardware in 3-mode architecture",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "effort": "medium",
      "dependencies": ["TASK-004", "TASK-005"],
      "functional_requirement": "FR6.1, FR6.2",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "Verify protocol generation logic in headless environment",
          "requirements": [
            "Algorithm for generating INI-style .cxprotocol format",
            "Calculate square crop from bounding box",
            "Center crop based on cell centroid",
            "Logic for including selection metadata",
            "Output format validation"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-protocol-export",
            "pytest tests/dev_mode/test_protocol_exporter.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "Verify consistency between GUI export and headless logic",
          "requirements": [
            "Synchronize GUI export dialog with backend logic",
            "Match progress display with actual processing state",
            "Accuracy of error message GUI display",
            "Verify automatic backup generation"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-export-dialog",
            "pytest tests/dual_mode/test_export_consistency.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "Export performance and stability in production environment",
          "requirements": [
            "Complete export within 10 seconds",
            "Stability in processing large datasets",
            "User-friendly progress display",
            "Error recovery and retry functionality"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-export",
            "pytest tests/gui_mode/test_export_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "Generate INI-style .cxprotocol format",
        "Include IMAGE and IMAGING_LAYOUT sections",
        "Calculate square crop from bounding box",
        "Center crop on cell centroid",
        "Include all selection metadata",
        "Export time within 10 seconds",
        "Output format validation",
        "Automatic backup generation"
      ],
      "implementation_file": "src/models/extractor.py",
      "technical_notes": "Protocol exporter with 3-mode architecture - configparser and crop calculation algorithms"
    },
    {
      "id": "TASK-007",
      "title": "Main Application Window Design",
      "description": "Implement main window with menu, toolbar, and layout in 3-mode architecture",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "effort": "medium",
      "dependencies": [],
      "functional_requirement": "NFR4.1",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "Simulate UI structure in headless environment",
          "requirements": [
            "Verify menu bar structure and action connections",
            "Toolbar items and shortcut key mapping",
            "Docking panel layout logic",
            "Status bar message system",
            "Keyboard shortcut handling"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-main-window-structure",
            "pytest tests/dev_mode/test_main_window.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "Verify consistency between GUI rendering and headless structure",
          "requirements": [
            "Match actual menu clicks with action mapping",
            "Verify toolbar button and function connections",
            "Confirm responsive layout behavior",
            "Test docking panel interactions"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-main-window-ui",
            "pytest tests/dual_mode/test_main_window_interaction.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "User experience and performance in production environment",
          "requirements": [
            "Compliance with Windows design guidelines",
            "Responsive layout performance",
            "Tooltips and context help",
            "Memory efficiency"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-main-window",
            "pytest tests/gui_mode/test_main_window_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "Implement File, Edit, View, Tools, Help menu bar",
        "Create toolbar for common tasks",
        "Design responsive layout with dockable panels",
        "Add status bar for user feedback",
        "Support keyboard shortcuts",
        "Comply with Windows design guidelines",
        "Include context help/tooltips"
      ],
      "implementation_file": "src/pages/main_window.py",
      "technical_notes": "QMainWindow implementation with 3-mode architecture - comprehensive UI"
    },
    {
      "id": "TASK-008",
      "title": "Add Cell Highlighting on Image",
      "description": "Implement functionality to display selected cells as overlay on microscopy image in 3-mode architecture",
      "type": "feature",
      "priority": "high",
      "status": "pending",
      "effort": "medium",
      "dependencies": ["TASK-001", "TASK-004"],
      "functional_requirement": "FR3.1",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "Simulate overlay logic in headless environment",
          "requirements": [
            "Calculate color markers and position determination",
            "Real-time update logic on selection changes",
            "Performance optimization for 10,000 cells",
            "Color consistency between plot and overlay",
            "Highlight 1,000 cells within 1 second"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-cell-highlighting",
            "pytest tests/dev_mode/test_cell_overlay.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "Verify consistency between GUI rendering and headless calculations",
          "requirements": [
            "Match actual image rendering with calculated positions",
            "Overlay visibility toggle behavior",
            "Color mapping accuracy",
            "Real-time update synchronization"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-overlay-rendering",
            "pytest tests/dual_mode/test_overlay_consistency.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "프로덕션 환경에서 시각적 성능 및 사용성",
          "requirements": [
            "대용량 이미지에서 부드러운 렌더링",
            "줌/팬 시 오버레이 동기화",
            "메모리 효율적인 페인팅",
            "사용자 인터랙션 반응성"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-overlay",
            "pytest tests/gui_mode/test_overlay_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "선택된 셀에 색상 마커 오버레이",
        "선택 변경 시 실시간 업데이트",
        "오버레이 가시성 토글",
        "10,000개 셀로 성능 유지",
        "플롯과 오버레이 간 색상 일치",
        "1,000개 셀을 1초 내 하이라이팅"
      ],
      "implementation_file": "src/models/image_handler.py (enhanced)",
      "technical_notes": "3모드 아키텍처를 적용한 Qt 페인팅 시스템 - 성능 최적화"
    },
    {
      "id": "TASK-009",
      "title": "96-웰 플레이트 할당 구현",
      "description": "표준 96-웰 플레이트 위치에 선택 항목을 할당하는 기능을 3모드로 구현",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "effort": "small",
      "dependencies": ["TASK-004"],
      "functional_requirement": "FR5.1, FR5.2",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "헤드리스 환경에서 웰 할당 로직 검증",
          "requirements": [
            "A01-H12 순서 자동 할당 알고리즘",
            "수동 오버라이드 로직",
            "중복 할당 방지 검증",
            "웰 할당 유효성 검사",
            "충돌 해결 알고리즘"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-well-assignment",
            "pytest tests/dev_mode/test_well_plate.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "GUI 인터랙션과 백엔드 로직 일치성 검증",
          "requirements": [
            "시각적 웰 플레이트 맵과 데이터 동기화",
            "클릭-투-셀렉트 기능 검증",
            "색상 코딩 정확성",
            "실시간 할당 업데이트"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-well-plate-ui",
            "pytest tests/dual_mode/test_well_plate_interaction.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "프로덕션 환경에서 사용자 경험 및 성능",
          "requirements": [
            "직관적인 웰 플레이트 인터페이스",
            "빠른 할당 및 수정",
            "시각적 피드백",
            "배치 할당 성능"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-well-plate",
            "pytest tests/gui_mode/test_well_plate_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "A01-H12 순서 자동 할당",
        "수동 오버라이드 기능",
        "중복 할당 방지",
        "웰 할당 유효성 검사",
        "충돌 해결 인터페이스",
        "시각적 웰 플레이트 맵 표시",
        "색상 코딩된 웰 및 클릭-투-셀렉트"
      ],
      "implementation_file": "src/components/widgets/well_plate.py",
      "technical_notes": "3모드 아키텍처를 적용한 웰 플레이트 모델 및 시각적 위젯"
    },
    {
      "id": "TASK-010",
      "title": "세션 관리 시스템 생성",
      "description": "분석 세션의 저장/로드 기능을 3모드로 구현",
      "type": "feature",
      "priority": "medium",
      "status": "pending",
      "effort": "medium",
      "dependencies": ["TASK-004", "TASK-005"],
      "functional_requirement": "NFR3.1",
      "three_mode_requirements": {
        "dev_mode": {
          "description": "헤드리스 환경에서 세션 직렬화/역직렬화 검증",
          "requirements": [
            "JSON 형식 세션 상태 저장",
            "모든 선택, 설정, 캘리브레이션 포함",
            "완전한 세션 복원",
            "자동 저장 기능",
            "버전 호환성 처리"
          ],
          "test_commands": [
            "python run.py --dev-mode --test-session-management",
            "pytest tests/dev_mode/test_session_manager.py -v"
          ],
          "status": "not_tested"
        },
        "dual_mode": {
          "description": "GUI 세션 인터페이스와 백엔드 동기화 검증",
          "requirements": [
            "세션 저장/로드 다이얼로그 동작",
            "진행률 표시 정확성",
            "에러 처리 및 메시지 표시",
            "세션 복구 인터페이스"
          ],
          "test_commands": [
            "python run.py --dual-mode --validate-session-ui",
            "pytest tests/dual_mode/test_session_consistency.py -v"
          ],
          "status": "not_tested"
        },
        "gui_mode": {
          "description": "프로덕션 환경에서 세션 관리 성능 및 안정성",
          "requirements": [
            "빠른 세션 저장/로드",
            "대용량 세션 처리",
            "안정적인 자동 저장",
            "세션 무결성 보장"
          ],
          "test_commands": [
            "python run.py --gui-mode --production-test-session",
            "pytest tests/gui_mode/test_session_production.py -v"
          ],
          "status": "not_tested"
        }
      },
      "acceptance_criteria": [
        "완전한 세션 상태를 JSON으로 저장",
        "모든 선택, 설정, 캘리브레이션 포함",
        "세션 완전 복원",
        "자동 저장 기능",
        "세션 복구 지원",
        "버전 호환성 처리",
        "이전 버전 백업"
      ],
      "implementation_file": "src/models/session_manager.py",
      "technical_notes": "3모드 아키텍처를 적용한 확장 가능한 JSON 형식 세션 관리"
    }
  ],
  "three_mode_metadata": {
    "architecture_version": "1.0",
    "mode_definitions": {
      "dev_mode": {
        "description": "헤드리스 시뮬레이션 + UX 검증",
        "command": "python run.py --dev-mode",
        "purpose": "모든 인터랙션을 헤드리스 환경에서 시뮬레이션하고 UX 표준 검증"
      },
      "dual_mode": {
        "description": "GUI 일치성 + 동기화 검증",
        "command": "python run.py --dual-mode", 
        "purpose": "GUI 렌더링이 DEV 모드 계산과 일치하는지 검증하고 실시간 동기화 테스트"
      },
      "gui_mode": {
        "description": "프로덕션 성능 + 실사용자 검증",
        "command": "python run.py --gui-mode",
        "purpose": "프로덕션 환경에서 성능, 안정성, 실제 사용자 인터랙션 검증"
      }
    },
    "testing_workflow": {
      "sequence": "DEV → DUAL → GUI",
      "mandatory": true,
      "integration_criteria": "모든 3모드 통과 후에만 코드 통합 가능"
    }
  },
  "metadata": {
    "total_tasks": 10,
    "by_status": {
      "completed": 4,
      "pending": 6,
      "in_progress": 0
    },
    "by_priority": {
      "high": 7,
      "medium": 3,
      "low": 0
    },
    "by_type": {
      "feature": 10,
      "infrastructure": 0,
      "testing": 0
    },
    "three_mode_coverage": {
      "tasks_with_three_mode": 6,
      "legacy_tasks": 4,
      "coverage_percentage": 60
    },
    "completion_percentage": 40,
    "requirements_compliance": {
      "functional_requirements": "88%",
      "non_functional_requirements": "90%", 
      "overall": "89%"
    },
    "production_status": "3모드 아키텍처 전환 중 - 핵심 기능 재구성"
  }
}