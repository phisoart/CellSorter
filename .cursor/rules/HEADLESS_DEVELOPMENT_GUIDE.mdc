---
description: headless GUI Development Guide
globs: 
alwaysApply: false
---
# Headless GUI Development Guide

## Introduction

This guide provides comprehensive instructions for developing CellSorter's GUI in headless environments using the Code Editing Mode. It enables developers and AI agents to create, modify, and test the user interface without requiring a display server.

## Core Principles

### 1. Development Mode First
- **ALWAYS** use `--dev-mode` flag when developing
- **NEVER** create QApplication in development mode
- Use YAML/JSON for all UI definitions

### 2. Terminal-Only Development
- All UI development must be possible via terminal
- No dependency on GUI designers or visual tools
- Output must be parseable by both humans and AI

### 3. Bidirectional Synchronization
- Changes in code MUST reflect in UI definitions
- Changes in UI definitions MUST reflect in code
- Round-trip editing must preserve all properties

## Quick Start

### 1. Environment Setup

```bash
# Check if running in headless mode
export CELLSORTER_DEV_MODE=true

# Optional: Force headless mode even with display
export CELLSORTER_FORCE_HEADLESS=true

# Run the application
python run.py --dev-mode
```

### Mode Detection Pattern
```python
# Always check mode before GUI operations
if is_dev_mode():
    # Work with UI definitions
    ui_manager = HeadlessUIManager()
else:
    # Normal GUI instantiation
    app = QApplication(sys.argv)
```

### 2. Development Workflow

#### Start Development
```bash
export CELLSORTER_DEV_MODE=true
python run.py --dev-mode
```

#### Modify UI
```bash
# Dump current UI
python run.py dump-ui > ui_definition.yaml

# Edit UI definition
# ... make changes ...

# Validate changes
python run.py validate-ui ui_definition.yaml

# Load changes
python run.py load-ui ui_definition.yaml
```

#### Test Changes
```bash
# Run headless tests
pytest tests/headless/

# Test with display (if available)
CELLSORTER_DEV_MODE=false python run.py
```

### 3. File Organization
```
ui_definitions/
├── main_window.yaml
├── dialogs/
│   ├── export_dialog.yaml
│   └── calibration_dialog.yaml
└── components/
    ├── scatter_plot.yaml
    └── selection_panel.yaml
```

## UI Definition Format

### Standard Widget Properties

All widgets share these common properties:

```yaml
# Common widget properties
name: string              # Unique identifier (required)
type: string              # Widget class name (required)
visible: boolean          # Default: true
enabled: boolean          # Default: true
geometry:                 # Position and size
  x: integer
  y: integer
  width: integer
  height: integer
size_policy:              # Size behavior
  horizontal: string      # Fixed, Minimum, Maximum, Preferred, Expanding
  vertical: string
minimum_size:             # Minimum dimensions
  width: integer
  height: integer
maximum_size:             # Maximum dimensions
  width: integer
  height: integer
style:                    # Visual properties
  stylesheet: string      # Qt stylesheet
  palette:                # Color scheme
    window: string
    windowText: string
    base: string
    alternateBase: string
    button: string
    buttonText: string
tooltip: string           # Hover text
whats_this: string        # Context help
font:                     # Text appearance
  family: string
  size: integer
  weight: string          # Normal, Bold
  italic: boolean
cursor: string            # Cursor shape
context_menu_policy: string  # Context menu behavior
```

### Layout System

```yaml
layout:
  type: string            # QVBoxLayout, QHBoxLayout, QGridLayout, QFormLayout
  properties:
    margin: integer       # Outer spacing
    spacing: integer      # Between items
    alignment: string     # AlignLeft, AlignRight, AlignCenter, etc.
  items:                  # Layout contents
    - widget: string      # Widget name reference
      stretch: integer    # Stretch factor
      alignment: string   # Item-specific alignment
    # For QGridLayout
    - widget: string
      row: integer
      column: integer
      row_span: integer
      column_span: integer
```

### Event Bindings

```yaml
events:
  # Signal-slot connections
  - signal: clicked                    # Signal name
    handler: on_button_clicked         # Handler method name
  
  # With arguments
  - signal: textChanged
    handler: on_text_changed
    connection_type: Qt.QueuedConnection  # Optional connection type
  
  # Lambda expressions (for simple cases)
  - signal: toggled
    handler: "lambda checked: print(f'Toggled: {checked}')"
```

## Widget Catalog

### Basic Widgets

#### QPushButton
```yaml
type: QPushButton
name: submitButton
properties:
  text: "Submit"
  icon: "icons/submit.png"
  checkable: false
  checked: false
  flat: false
  default: true
events:
  - signal: clicked
    handler: on_submit_clicked
```

#### QLabel
```yaml
type: QLabel
name: titleLabel
properties:
  text: "CellSorter Analysis"
  alignment: AlignCenter
  word_wrap: true
  text_format: RichText  # PlainText, RichText, MarkdownText
  pixmap: null
  scaled_contents: false
```

#### QLineEdit
```yaml
type: QLineEdit
name: filePathEdit
properties:
  text: ""
  placeholder_text: "Enter file path..."
  max_length: 255
  echo_mode: Normal  # Normal, Password, NoEcho
  input_mask: ""
  validator: IntValidator  # Optional validator type
  read_only: false
events:
  - signal: textChanged
    handler: on_path_changed
  - signal: returnPressed
    handler: on_path_submitted
```

#### QComboBox
```yaml
type: QComboBox
name: modeSelector
properties:
  items:
    - "Analysis Mode"
    - "Calibration Mode"
    - "Export Mode"
  current_index: 0
  editable: false
  max_visible_items: 10
events:
  - signal: currentIndexChanged
    handler: on_mode_changed
```

### Container Widgets

#### QGroupBox
```yaml
type: QGroupBox
name: settingsGroup
properties:
  title: "Analysis Settings"
  checkable: true
  checked: true
  flat: false
layout:
  type: QFormLayout
  items:
    - label: "Threshold:"
      widget: thresholdSpinBox
    - label: "Method:"
      widget: methodComboBox
```

#### QTabWidget
```yaml
type: QTabWidget
name: mainTabs
properties:
  tab_position: North  # North, South, East, West
  tabs_closable: false
  movable: true
  document_mode: false
tabs:
  - title: "Analysis"
    widget: analysisPanel
    icon: "icons/analysis.png"
  - title: "Results"
    widget: resultsPanel
    enabled: false
```

### Advanced Widgets

#### QTableWidget
```yaml
type: QTableWidget
name: dataTable
properties:
  row_count: 10
  column_count: 5
  headers:
    horizontal: ["ID", "Name", "Value", "Status", "Action"]
    vertical: null  # No vertical headers
  selection_behavior: SelectRows
  selection_mode: ExtendedSelection
  sorting_enabled: true
  alternating_row_colors: true
  grid_style: SolidLine
events:
  - signal: cellClicked
    handler: on_cell_clicked
  - signal: itemSelectionChanged
    handler: on_selection_changed
```

## Development Patterns

### 1. Component-Based Design

```yaml
# Define reusable components
components:
  ActionButton:
    type: QPushButton
    base_properties:
      minimum_height: 32
      font:
        weight: Bold
      style:
        stylesheet: |
          QPushButton {
            background-color: #3498db;
            color: white;
            border-radius: 4px;
            padding: 8px 16px;
          }
          QPushButton:hover {
            background-color: #2980b9;
          }

# Use components
widgets:
  - type: ActionButton
    name: saveButton
    properties:
      text: "Save"
    events:
      - signal: clicked
        handler: on_save
```

### 2. Dynamic UI Generation

```python
# Python code to generate UI definition
def create_button_panel(button_count):
    panel = {
        "type": "QWidget",
        "name": "buttonPanel",
        "layout": {
            "type": "QHBoxLayout",
            "items": []
        }
    }
    
    for i in range(button_count):
        button = {
            "type": "QPushButton",
            "name": f"button_{i}",
            "properties": {
                "text": f"Button {i+1}"
            },
            "events": [{
                "signal": "clicked",
                "handler": f"on_button_{i}_clicked"
            }]
        }
        panel["layout"]["items"].append({"widget": f"button_{i}"})
        
    return panel
```

### 3. State Management

```yaml
# UI state definition
state:
  current_mode: "analysis"
  data_loaded: false
  selections: []
  
# State-dependent UI
widgets:
  - type: QPushButton
    name: analyzeButton
    properties:
      enabled: "{{state.data_loaded}}"  # Template binding
      text: "Analyze"
```

## Testing in Headless Mode

### 1. Unit Testing UI Structure

```python
import pytest
from headless_ui import load_ui_definition, find_widget

def test_main_window_structure():
    ui = load_ui_definition('ui/main_window.yaml')
    
    # Test window exists
    main_window = find_widget(ui, 'mainWindow')
    assert main_window is not None
    assert main_window['type'] == 'QMainWindow'
    
    # Test required buttons exist
    assert find_widget(ui, 'openButton') is not None
    assert find_widget(ui, 'saveButton') is not None
    
    # Test layout structure
    central_widget = find_widget(ui, 'centralWidget')
    assert central_widget['layout']['type'] == 'QVBoxLayout'
```

### 2. Integration Testing

```python
def test_ui_events():
    ui = load_ui_definition('ui/main_window.yaml')
    
    # Find button and check event handler
    button = find_widget(ui, 'submitButton')
    events = button.get('events', [])
    
    assert any(e['signal'] == 'clicked' for e in events)
    assert any(e['handler'] == 'on_submit_clicked' for e in events)
```

### 3. Visual Regression Testing

```python
def test_ui_snapshot():
    ui = load_ui_definition('ui/main_window.yaml')
    
    # Generate text representation
    snapshot = generate_ui_snapshot(ui)
    
    # Compare with baseline
    with open('tests/ui_baseline.txt', 'r') as f:
        baseline = f.read()
    
    assert snapshot == baseline, "UI structure has changed"
```

## AI Agent Integration

### 1. Task Instructions

```markdown
## UI Modification Task

Modify the main window to add a new toolbar with the following buttons:
1. "Import" button with icon "icons/import.png"
2. "Export" button with icon "icons/export.png"
3. "Settings" button with icon "icons/settings.png"

The toolbar should be docked at the top and movable.
```

### 2. AI-Friendly Commands

```bash
# AI can use these commands
ui-assistant add-widget --type=QToolBar --name=mainToolBar --parent=mainWindow
ui-assistant add-action --toolbar=mainToolBar --name=importAction --text="Import" --icon="icons/import.png"
ui-assistant connect-signal --widget=importAction --signal=triggered --handler=on_import
```

### 3. Validation Rules for AI

```yaml
# Rules file for AI modifications
rules:
  naming:
    - pattern: "^[a-zA-Z][a-zA-Z0-9_]*$"
      message: "Widget names must be valid Python identifiers"
  
  hierarchy:
    - rule: "QMainWindow must have exactly one central widget"
    - rule: "QLayout cannot be child of QLayout"
  
  properties:
    - widget_type: QPushButton
      required: ["text"]
      optional: ["icon", "tooltip", "enabled"]
```

## Best Practices

### 1. Naming Conventions

```yaml
# Good naming
widgets:
  - name: submitButton        # Descriptive, camelCase
  - name: userNameEdit        # Clear purpose
  - name: mainToolBar         # Component type suffix

# Bad naming
widgets:
  - name: btn1               # Too short, unclear
  - name: widget_2           # Generic name
  - name: MyButton           # Inconsistent case
```

### 2. Organization

```yaml
# Organize by functional areas
ui_definition:
  metadata:
    version: "1.0"
    created: "2024-01-01"
    
  components:
    # Reusable component definitions
    
  windows:
    main_window:
      # Main window definition
      
    dialogs:
      # Dialog definitions
      
  resources:
    # Icons, stylesheets, etc.
```

### 3. Documentation

```yaml
# Document complex widgets
widgets:
  - type: QTableWidget
    name: analysisResultsTable
    documentation: |
      Displays analysis results with sortable columns.
      Double-click to view details.
      Right-click for context menu.
    properties:
      # ... properties
```

## Troubleshooting

### Common Issues

1. **Widget not appearing**
   - Check parent-child relationships
   - Verify layout inclusion
   - Ensure visible: true

2. **Events not firing**
   - Verify handler method exists
   - Check signal name spelling
   - Ensure widget is enabled

3. **Layout problems**
   - Check stretch factors
   - Verify spacing/margins
   - Test with different content

### Debug Mode

```bash
# Enable verbose UI loading
export CELLSORTER_UI_DEBUG=true

# Show widget hierarchy
python run.py --show-widget-tree

# Validate specific widget
python run.py --validate-widget mainWindow.submitButton
```

## Migration Guide

### Converting Existing UI Code

```python
# Original PySide6 code
button = QPushButton("Submit")
button.setObjectName("submitButton")
button.clicked.connect(self.on_submit)
layout.addWidget(button)

# Converts to YAML
- type: QPushButton
  name: submitButton
  properties:
    text: "Submit"
  events:
    - signal: clicked
      handler: on_submit
```

### Gradual Migration Strategy

1. Start with dialogs (isolated components)
2. Move to panels and widgets
3. Finally migrate main window
4. Keep backward compatibility throughout

## Security Rules

### 1. Input Validation
- Validate all widget types
- Check property values
- Prevent code injection

### 2. Safe Parsing
```python
# Always use safe loaders
ui_def = yaml.safe_load(text)  # ✓
# ui_def = eval(text)  # ✗ NEVER
```

## Performance Guidelines

### 1. Lazy Loading
- Load UI components on demand
- Cache parsed definitions
- Minimize memory usage

### 2. Efficient Updates
- Update only changed widgets
- Batch property changes
- Avoid full UI rebuilds

## Version Control

### 1. Commit Messages
- Use conventional commits
- Reference task numbers
- Include validation status

### 2. UI Definition Changes
```bash
git add ui_definitions/
git commit -m "feat(ui): Add export toolbar

- Added toolbar definition
- Validated in headless mode
- Tests updated"
```

## Debugging

### 1. Enable Debug Mode
```bash
export CELLSORTER_DEBUG=true
export CELLSORTER_UI_TRACE=true
```

### 2. Validation Output
```bash
python run.py validate-ui --verbose ui_definition.yaml
```

## Forbidden Practices

NEVER:
- Create QApplication in dev mode
- Use eval() on UI definitions
- Hardcode absolute paths
- Skip validation
- Ignore test failures
- Assume display availability
- Use undocumented properties
- Break backward compatibility

## Success Criteria

Every development session must:
- ✅ Pass validation
- ✅ Work in headless mode
- ✅ Maintain UI consistency
- ✅ Update documentation
- ✅ Pass all tests
- ✅ Be reviewable in text format

## Resources

- [UI Schema Reference](mdc:ui_schema.yaml)
- [Widget Property Reference](mdc:widget_properties.md)
- [Example UI Definitions](mdc:examples)
- [Test Suites](mdc:tests/headless)
